작업폴더에서 git 쓰고 싶으면 터미널에 (git init) 부터 입력

파일 현재상태를 기록해두려면 (git add 파일명)
(git commit -m '메모')

[작업폴더] --(git add)--> [staging area] --(git commit)--> [repository]

여러파일 스테이징 하려면 
(git add 파일1 파일2)
ex) (git add app.txt app2.txt)

모든파일 스테이징하려면 
(git add .)

상태창열기
(git status)

commit내역 조회
(git log --all --oneline) (git log --all --oneline --graph)   종료 = q

작업덩어리 하나 완성 수정 됬을때 마다 쓰는거 장려!

최근 commit vs 현재파일 차이점 보여줌
(git diff) 혹은 (git difftool)  종료 = :qa

특정commit vs 현재파일 차이점 보여줌
(git difftool 커밋아이디)

특정commit vs 다른특정commit 차이점 보여줌
(git difftool 커밋아이디 다른커밋아이디)

그냥 vscode에 있는 소스제어에서 확장설치한 git graph같은 기능 쓰는게 보기 쉬움

원본파일에 새로운코드 짜다가 망칠우려가 클때 복사본을 만들어서 거기에 먼저 코드짜보셈
- 파일 복붙해도되지만 git branch 기능이 있음
- 브랜치 생성 (git branch 작명)
- 브랜치로 이동 (git switch 아까작명했던거)

master(main)에서 새로생성됬던 브랜치를 합치길 원할경우
(git merge 합칠브랜치이름) 
ex)
- master 에서 a번파일 수정, 타브랜치에서 b번파일 수정 => 해피엔딩
- master 에서 a번파일 1번줄 수정, 타브랜치에서 a번파일 1번줄 수정 => 충돌(conflict)

다양한 브랜치 합치는 경우
case 1. 각 브랜치에서 신규 commit 이 있는 경우 - 3-way merge 위에 처럼 함

case 2. 기준 브랜치에 신규 commit 이 없는 경우 - 새로운 브랜치가 master(main)브랜치로 지칭함 fast-forward merge라 함
        기준이 되는 브랜치에 신규 commit이 없으면 자동으로 fast-forward merge가 발동됨 
        그게 싫다면 (git merge --no-ff 브랜드명)해서 강제로 3-way merge 할수도 있음

# merge 완료된 브랜치 삭제는 (git branch -d 브랜치명)
# merge 안한 브랜치 삭제는 (git branch -D 브랜치명)

merge말고 다른방식으로 합칠수 있음
rebase 써도 브랜치 합칠수 있음

case 3. git rebase & merge 기준이 되는 브랜치에서 가장 최근 commit이 아닌 상태에서 파생된 신규 브랜치 commit들이 있을때 
        즉 3-way 상태를 rebase로 브랜치의 시작점을 master브랜치의 최근 커밋으로 옮겨서 fast-forward merge하게 함
        예시1) masterBranch commit1 - commit2 - commit3
              newBranch               ㄴcommit2-1 - commit2-2

        예시2) masterBranch commit1 - commit2 - commit3
               newBranch                                ㄴ commit2-1 - commit2-2

        쓰는 이유 : 3-way merge는 나중에 git log 출력할때 복잡해보임
        단점 : conflict 엔딩 많이 남

        쓰는 법 : 1. 새로운브랜치(newBranch)로 이동해서
                  2. (git rebase 중심브랜치명(master나 main)) -- 여기까지 rebase
                  3. 중심브랜치로 이동해서
                  4. (git merge 새로운브랜치명)

case 4. squash and merge
        새로운 브랜치에 있는 commit들을 다 합쳐서 master브랜치에 새로운 commit으로 만들어줌
        예시1) masterBranch commit1 - commit2 - commit3
              newBranch               ㄴcommit2-1 - commit2-2
        예시2) masterBranch commit1 - commit2 - commit3 - commit4 (newBranch)              

        쓰는 이유 : git merge를 계속하다보면 git commit 내역들이 더러워짐 master(main)브랜치 로그만 보고싶어도 다른 브랜치도 나옴 그 선을 끊는 방법은 rebase도 있지만 squash and merge쓸수 있음                     

        쓰는 법 : (git merge --squash 새브랜치)


코드짜다가 실수했을떄 되돌아가자
git은 파일복구가능, commit복구 가능,과거로 이동 가능함

특정 파일을 최근 commit으로 복구하는법 
(git restore 파일명)

특정 파일을 특정 commit 시점으로 복구하는법
(git restore --source 커밋아이디 파일명)

특정파일을 add해놓은걸 staging취소 하고싶을때
(git restore --staged 파일명)


특정 commit 취소하는법 : 전에 어떤 커밋을 삭제하진 못하고 그 커밋을 취소하고 작업했던 새로 그 당시 작업했던게 사라진 버전의 commit이 생성됨 
예) a,b,c파일 순서대로 추가하면서 각각 commit을 만들었을떄 b를 생성했을떄 작업내역을 없애고 싶으면 a,c만 있는 새로운버전의 commit이 생김
(git revert 커밋아이디)

특정commit 여러개 동시에 취소가능
(git revert 커밋아이디1 커밋아이디2)

최근 commit취소가능
(git revert HEAD)


과거로 모든걸 되돌리기 : 위험함
(git reset --hard 커밋아이디)

과거로 되돌리지만 변동사항을 지우지말고 스테이징해놓기
(git reset --soft 커밋아이디)

과거로 되돌리지만 변동사항을 지우지말고 unstage해놓기
(git reset --mixed 커밋아이디)


로컬저장소 -> 원격저장소 업로드
(git push -u 원격저장소주소 올릴로컬브랜치명) 
        # 보통 -u 는 추가하면 주소 기억하라는 뜻 그 다음부터는 (git push) 만 해도 했던 주소로 된다지만 난 실패함

원격저장소주소 변수로 만들기 : 여기선 origin으로 함
(git remote add 변수명 원격저장소주소)




